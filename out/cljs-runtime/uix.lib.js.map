{"version":3,"sources":["uix/lib.cljc"],"mappings":";;;;AAwBG,qBAAA,rBAAMA,kDAASC;AAAf,AACE,OAACC,oBAAU,WAAKC,EAAEC,EAAEC;AAAT,AACE,AAACC,oCAASH,EAAE,AAACI,eAAKH,GAAGC;;AACrBF;GAFb,KAIWF","names":["uix.lib/map->js","m","cljs.core/reduce-kv","o","k","v","uix.lib.goog$module$goog$object.set","cljs.core/name"],"sourcesContent":["(ns uix.lib\n  #?(:cljs (:require-macros [uix.lib :refer [doseq-loop]]))\n  #?(:cljs (:require [goog.object :as gobj]))\n  #?(:clj (:require [cljs.analyzer :as ana]\n                    [clojure.walk]\n                    [cljs.core])))\n\n#?(:clj\n   (defmacro assert! [x message]\n     `(when-not ~x\n        (throw (new AssertionError (str \"Assert failed: \" ~message \"\\n\" (pr-str '~x)))))))\n\n#?(:clj\n   (defmacro doseq-loop [[v vs] & body]\n     `(let [v# ~vs]\n        (when (seq v#)\n          (loop [x# (first v#)\n                 xs# (next v#)]\n            (let [~v x#]\n              ~@body)\n            (when (seq xs#)\n              (recur (first xs#) (next xs#))))))))\n\n#?(:cljs\n   (defn map->js [m]\n     (reduce-kv (fn [o k v]\n                  (gobj/set o (name k) v)\n                  o)\n                #js {}\n                m)))\n\n#?(:clj\n   (defn cljs-env? [env]\n     (boolean (:ns env))))\n\n#?(:clj\n   (defn find-form [pred sexp]\n     (let [forms (atom [])]\n       (clojure.walk/prewalk\n        (fn [x]\n          (when (pred x)\n            (swap! forms conj x))\n          x)\n        sexp)\n       @forms)))\n\n#?(:clj\n   (defn parse-sig [name fdecl]\n     (let [[fdecl m] (if (string? (first fdecl))\n                       [(next fdecl) {:doc (first fdecl)}]\n                       [fdecl {}])\n           [fdecl m] (if (map? (first fdecl))\n                       [(next fdecl) (conj m (first fdecl))]\n                       [fdecl m])\n           fdecl (if (vector? (first fdecl))\n                   (list fdecl)\n                   fdecl)\n           [fdecl m] (if (map? (last fdecl))\n                       [(butlast fdecl) (conj m (last fdecl))]\n                       [fdecl m])\n           m (conj {:arglists (list 'quote (#'cljs.core/sigs fdecl))} m)\n           m (conj (if (meta name) (meta name) {}) m)]\n       [(with-meta name m) fdecl])))\n\n#?(:clj\n   (do\n     (defn- uix-element?\n       \"Returns true when `form` is `(uix.core/$ ...)`\"\n       [env form]\n       (let [resolve-fn (if (uix.lib/cljs-env? env)\n                          ana/resolve-var\n                          resolve)]\n         (and (list? form)\n              (symbol? (first form))\n              (->> (first form) (resolve-fn env) :name (= 'uix.core/$)))))\n\n     (def elements-list-fns\n       '#{for map mapv filter filterv remove keep keep-indexed})\n\n     (defn- elements-list?\n       \"Returns true when `v` is form commonly used to render a list of elements\n       `(map ...)`, `(for ...)`, etc\"\n       [v]\n       (and (list? v)\n            (symbol? (first v))\n            (elements-list-fns (first v))))\n\n     (defn normalize-element\n       \"When the second item in the element `v` is either UIx element or `elements-list?`,\n  returns normalized element with empty map at props position\n  and child element shifted into children position\"\n       [env v]\n       (if (or (uix-element? env (second v))\n               (elements-list? (second v)))\n         (into [(first v) {}] (rest v))\n         v))))\n"],"x_google_ignoreList":[0]}