{"version":3,"sources":["uix/compiler/input.cljs"],"mappings":"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","names":["uix.compiler.input/these-inputs-have-selection-api","uix.compiler.input/has-selection-api?","input-type","cljs.core/contains?","uix.compiler.input/should-use-reagent-input?","js/reagent","js/reagent.impl","js/reagent.impl.util","js/reagent.impl.util.*non-reactive*","cljs.core/not","uix.compiler.input/do-after-render","f","js/reagent.impl.batching.do-after-render","uix.compiler.input/input-node-set-value","node","rendered-value","dom-value","component","js/document","node-value","cljs.core._EQ_","existing-offset-from-end","cljs.core/count","new-cursor-offset","uix.compiler.input/input-component-set-value","this","cljs.core.not_EQ_","uix.compiler.input/input-handle-change","on-change","e","uix.compiler.input/input-render-setup","jsprops","and__5043__auto__","v","value","original-ref-fn","cljs.core/fn?","el","p1__28217#","uix.compiler.input/input-unmount","uix.compiler.input/reagent-input","js-props","js/module$node_modules$react$index.useRef","js/module$node_modules$react$index.useLayoutEffect","js/undefined","js/module$node_modules$react$index.useEffect","cljs.core.apply","js/module$node_modules$react$index.createElement"],"sourcesContent":["(ns uix.compiler.input\n  \"Copied and adapted from https://github.com/reagent-project/reagent/blob/3b2047391ee2d217f257d9b8a7a99b3b4eff29d2/src/reagent/impl/input.cljs\"\n  (:require [react]))\n\n;; <input type=\"??\" >\n;; The properties 'selectionStart' and 'selectionEnd' only exist on some inputs\n;; See: https://html.spec.whatwg.org/multipage/forms.html#do-not-apply\n(def these-inputs-have-selection-api #{\"text\" \"textarea\" \"password\" \"search\"\n                                       \"tel\" \"url\"})\n\n(defn ^boolean has-selection-api?\n  [input-type]\n  (contains? these-inputs-have-selection-api input-type))\n\n(defn should-use-reagent-input? []\n  (and (exists? js/reagent.impl.util.*non-reactive*)\n       (not js/reagent.impl.util.*non-reactive*)))\n\n(defn do-after-render [f]\n  (js/reagent.impl.batching.do-after-render f))\n\n(declare input-component-set-value)\n\n(defn input-node-set-value\n  [node rendered-value dom-value ^clj component]\n  (if-not (and (identical? node (.-activeElement js/document))\n               (has-selection-api? (.-type node))\n               (string? rendered-value)\n               (string? dom-value))\n    ;; just set the value, no need to worry about a cursor\n    (do\n      (set! (.-cljsDOMValue component) rendered-value)\n      (set! (.-value node) rendered-value))\n\n    ;; Setting \"value\" (below) moves the cursor position to the\n    ;; end which gives the user a jarring experience.\n    ;;\n    ;; But repositioning the cursor within the text, turns out to\n    ;; be quite a challenge because changes in the text can be\n    ;; triggered by various events like:\n    ;; - a validation function rejecting a user inputted char\n    ;; - the user enters a lower case char, but is transformed to\n    ;;   upper.\n    ;; - the user selects multiple chars and deletes text\n    ;; - the user pastes in multiple chars, and some of them are\n    ;;   rejected by a validator.\n    ;; - the user selects multiple chars and then types in a\n    ;;   single new char to repalce them all.\n    ;; Coming up with a sane cursor repositioning strategy hasn't\n    ;; been easy ALTHOUGH in the end, it kinda fell out nicely,\n    ;; and it appears to sanely handle all the cases we could\n    ;; think of.\n    ;; So this is just a warning. The code below is simple\n    ;; enough, but if you are tempted to change it, be aware of\n    ;; all the scenarios you have handle.\n    (let [node-value (.-value node)]\n      (when (= node-value dom-value)\n        (let [existing-offset-from-end (- (count node-value)\n                                          (.-selectionStart node))\n              new-cursor-offset        (- (count rendered-value)\n                                          existing-offset-from-end)]\n          (set! (.-cljsDOMValue component) rendered-value)\n          (set! (.-value node) rendered-value)\n          (set! (.-selectionStart node) new-cursor-offset)\n          (set! (.-selectionEnd node) new-cursor-offset))))))\n\n(defn input-component-set-value [^clj this]\n  (when (.-cljsInputLive this)\n    (set! (.-cljsInputDirty this) false)\n    (let [rendered-value (.-cljsRenderedValue this)\n          dom-value (.-cljsDOMValue this)\n          ;; Default to the root node within this component\n          node (.-inputEl this)]\n      (when (not= rendered-value dom-value)\n        (input-node-set-value node rendered-value dom-value this)))))\n\n(defn input-handle-change [^clj this on-change e]\n  (set! (.-cljsDOMValue this) (-> e .-target .-value))\n  ;; Make sure the input is re-rendered, in case on-change\n  ;; wants to keep the value unchanged\n  (when-not (.-cljsInputDirty this)\n    (set! (.-cljsInputDirty this) true)\n    (do-after-render #(input-component-set-value this)))\n  (on-change e))\n\n(defn input-render-setup\n  [^clj this ^js jsprops]\n  ;; Don't rely on React for updating \"controlled inputs\", since it\n  ;; doesn't play well with async rendering (misses keystrokes).\n  (when (and (some? jsprops)\n             (.hasOwnProperty jsprops \"onChange\")\n             (.hasOwnProperty jsprops \"value\"))\n    (let [v (.-value jsprops)\n          value (if (nil? v) \"\" v)\n          on-change (.-onChange jsprops)\n          original-ref-fn (.-ref jsprops)]\n      (when-not (.-cljsInputLive this)\n        ;; set initial value\n        (set! (.-cljsInputLive this) true)\n        (set! (.-cljsDOMValue this) value))\n      (when-not (.-reagentRefFn this)\n        (set! (.-reagentRefFn this)\n              (cond\n                ;; ref fn\n                (fn? original-ref-fn)\n                (fn [el]\n                  (set! (.-inputEl this) el)\n                  (original-ref-fn el))\n\n                ;; react/createRef object\n                (and original-ref-fn (.hasOwnProperty original-ref-fn \"current\"))\n                (fn [el]\n                  (set! (.-inputEl this) el)\n                  (set! (.-current original-ref-fn) el))\n\n                :else\n                (fn [el]\n                  (set! (.-inputEl this) el)))))\n      (set! (.-cljsRenderedValue this) value)\n      (js-delete jsprops \"value\")\n      (set! (.-defaultValue jsprops) value)\n      (set! (.-onChange jsprops) #(input-handle-change this on-change %))\n      (set! (.-ref jsprops) (.-reagentRefFn this)))))\n\n(defn input-unmount [^js this]\n  (set! (.-cljsInputLive this) nil))\n\n(defn reagent-input [^js js-props]\n  (let [this (.-current (react/useRef #js {}))]\n    (input-render-setup this (.-props js-props))\n    (when (exists? js/document)\n      (react/useLayoutEffect\n       (fn []\n         (input-component-set-value this)\n         js/undefined)))\n    (react/useEffect\n     (fn [] #(input-unmount this))\n     #js [])\n    (apply react/createElement (.-tag js-props) (.-props js-props) (.-children js-props))))\n\n"],"x_google_ignoreList":[0]}